# Вы не знаете JS: Типы и грамматика
# Глава 4: Приведение

Теперь, когда мы гораздо более полно понимаем типы и значения Javascript, мы обратим наше внимание на очень спорную тему: приведение.

Как мы упоминали в Главе 1, споры о том, является ли приведение полезной возможностью или недостатком языка (или чем-то посередине!) бушевали с первого дня. Если вы читали другие популярные книги по JS, вы знаете, что в подавляющем большинстве случаев распространено *мнение* о том, что приведение - это волшебство, зло, путаница и просто совершенно плохая идея.

Следуя духу этой серии книг, вместо того, чтобы убегать от приведения значений, потому что так делают все остальные, или потому, что вас укусила какая-то муха, я думаю, вам следует заняться тем, чего вы не понимаете, и попытаться лучше *схватить* это.

Наша цель - полностью изучить плюсы и минусы (да, *есть* плюсы!) приведения, чтобы вы могли принять обоснованное решение о его целесообразности в вашем коде.

## Конвертация значений

Конвертация значения из одного типа в другой часто называется "преобразованием типа", когда делается явно, и "приведением", когда выполняется неявно (диктуется правилами использования значения).

**Примечание:** Это может быть неочевидно, но результат приведения в JavaScript это всегда значение скалярного примитива (см. Главу 2), например, `string`, `number`, или `boolean`. Не существует приведения, которое бы приводило к созданию сложного значения, такого как `object` или `function`. Глава 3 посвящена "упаковке", которая помещает скалярные примитивные значения в их `object`-аналоги, но на самом деле это не приведение в строгом смысле слова.

Другой распространенный способ различения этих терминов состоит в следующем: "преобразование типов" (или "конвертация типов") выполняется в статически типизированных языках во время компиляции, а "приведение типов" - это преобразование во время выполнения в динамически типизированных языках.

Однако в JavaScript большинство людей называют все эти виды преобразований *приведением*, поэтому я предпочитаю обозначать их как "неявное приведение" и "явное приведение".

Разница должна быть очевидной: "явное приведение" - это когда при взгляде на код ясно, что преобразование типа выполняется намеренно, тогда как "неявное приведение" - это когда преобразование - это менее очевидный побочный эффект какой-либо другой намеренной операции.

Для примера рассмотрим эти два способа приведения:

```js
var a = 42;

var b = a + "";			// неявное приведение

var c = String( a );	// явное приведение
```

В случае с `b` возникающее приведение происходит неявно, потому что оператор `+` в сочетании с одним из операндов, являющимся строковым значением (`""`), будет настаивать на том, что это операция конкатенации строк (сложения двух `string` вместе), что *в качестве (скрытого) побочного эффекта* приведет к тому, что значение `42` в `a` будет приведено к его строковому эквиваленту: `"42"`.

Напротив, функция `String(..)` делает конвертацию очевидной, так как она явно берёт значение в `a` и приводит его к `string` представлению.

Оба подхода приводят к одному и тому же результату: из `42` получается `"42"`. Но именно то, как это делается, лежит в основе жарких дебатов о приведении в JavaScript.

**Примечание**: Технически, здесь, помимо стилистических различий, есть и нюансы в разном поведении. Мы рассмотрим их более подробно позже в разделе "Неявно: Строки <--> Числа".

Термины "явный" и "неявный", или "очевидный" и "скрытый побочный эффект", *относительны*.

Если вы точно знаете, что делает `a + ""`, и вы намеренно пишете это, чтобы привести к `string`, вы можете воспринимать эту операцию достаточно "явной". И наоборот, если вы никогда не видели функцию `String(..)`, используемую для приведения к `string`, ее поведение может показаться достаточно скрытым, чтобы стать для вас "неявным".

Но мы ведем это обсуждение "явного" и "неявного" с точки зрения *среднего, достаточно информированного разработчика, но не эксперта или поборника JS спецификации*. В какой бы степени такое описание ни подходило вашему мироощущению, вам необходимо сделать поправку на наш угол обзора здесь.

Просто помните: часто бывает так, что мы пишем наш код и являемся единственными, кто его читает. Даже если вы являетесь экспертом во всех тонкостях JS, подумайте, что почувствуют ваши менее опытные товарищи по команде, когда прочтут ваш код. Будет ли он "явным" или "неявным" для них так же, как и для вас?

## Абстрактные операции со значениями

Прежде чем мы сможем приступить к *явному* и *неявному* приведению, нам нужно изучить базовые правила, которые определяют, как значения *становятся* `string`, `number` или `boolean`. Спецификация ES5 в разделе 9 определяет несколько "абстрактных операций" (затейливо обозначенные как "исключительно внутренние операции") с правилами конвертации значений. Мы специально обратим внимание на: `ToString`, `ToNumber`, `ToBoolean` и, в меньшей степени, на `ToPrimitive`.

### `ToString`

Когда любое не строковое значение приводится в `string`-представление, преобразование выполняется абстрактной операцией `ToString` из раздела 9.8 спецификации.

Встроенные примитивные значения имеют естественную строковое отображение: `null` становится `"null"`, `undefined` превращается в `"undefined"`, а `true` конвертируется в `"true"`. Числа (`number`) обычно представляются ожидаемым вами образом, но, как мы обсуждали в Главе 2, очень маленькие или очень большие числа представляются в экспоненциальной форме:

```js
// умножим `1.07` на `1000` семь раз
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

// семь раз по три цифры => 21 цифра
a.toString(); // "1.07e21"
```

Для обычных объектов, если вы не укажете свой собственный, по умолчанию используется `toString()` (находится в `Object.prototype.toString()`), который вернет *внутренний `[[Class]]`* (см. Главу 3). Например, `"[object Object]"`.

Но, как было показано ранее, если у объекта есть свой собственный метод `toString()`, и вы используете этот объект как `string`, автоматически будет вызван его `toString()`, и вместо объекта будет использован `string`-результат этого метода.

**Примечание:** Технически путь приведения объекта к `string` пролегает через абстрактную операцию `ToPrimitive` (Спецификация ES5, раздел 9.1), но эти нюансы более подробно рассматриваются позже в разделе `ToNumber`, поэтому мы пропустим их здесь.

У массивов базовый метод `toString()` переопределён и представляет собой сцепление всех его значений в виде строк через разделитель `","` (строковое представление каждого значения формируется индивидуально):

```js
var a = [1,2,3];

a.toString(); // "1,2,3"
```

Опять же, `toString()` может быть либо вызван явно, либо он будет вызван автоматически, если не строковое значение используется в `string`-контексте.

#### Строковое преобразование JSON

Другая задача, которая, казалось бы, плохо связанна с `ToString`, - это когда вы используете утилиту `JSON.stringify(..)` для сериализации значения в строковый вид, совместимый с JSON.

Важно отметить, что это строковое преобразование - не совсем то же самое, что приведение. Но поскольку оно связано с приведенными выше правилами `ToString`, мы сделаем небольшое отступление, чтобы рассмотреть логику строкового преобразования JSON.

Обычно для большинства простых значений строковое преобразование JSON  ведет себя так же, как `toString()`, за исключением того, что результатом сериализации *всегда является `string`*:

```js
JSON.stringify( 42 );	// "42"
JSON.stringify( "42" );	// ""42"" (строка с закавыченным строковым значением)
JSON.stringify( null );	// "null"
JSON.stringify( true );	// "true"
```

Любое *безопасное для JSON* значение может быть преобразовано в строку с помощью `JSON.stringify(..)`. Но что такое *безопасное для JSON*? Любое значение, которое может быть корректно отображено в представлении JSON.

Вероятно, проще будет назвать значения, которые **не** являются безопасными для JSON. Некоторые примеры: `undefined`, `function`, `symbol` (ES6+) и `object` с циклическими ссылками (где ссылки на свойства объекта создают замкнутый круг, указывая друг на друга). Все это недопустимые значения для стандартной структуры JSON, главным образом потому, что они не переносимы на другие языки, которые используют JSON-данные.

Утилита `JSON.stringify(..)` автоматически опустит значения `undefined`, `function` и `symbol`, когда столкнется с ними. Если такое значение окажется в `array`, то оно заменяется на `null` (чтобы сохранить информацию о местоположении элементов в массиве). Если любое из них хранится в свойстве `object`, это свойство будет просто исключено.

Рассмотрим:

```js
JSON.stringify( undefined );					// undefined
JSON.stringify( function(){} );					// undefined

JSON.stringify( [1,undefined,function(){},4] );	// "[1,null,null,4]"
JSON.stringify( { a:2, b:function(){} } );		// "{"a":2}"
```

Но если вы попытаетесь передать в `JSON.stringify(..)` любой `object` с циклическими ссылками, то будет выдана ошибка.

Строковое преобразование JSON ведет себя иначе, если в передаваемом ему `object` определен метод `toJSON()`. Этот метод будет вызван первым, чтобы получить сериализованное значение.

Если вы собираетесь преобразовывать в JSON строку объект, который может содержать недопустимые JSON-значения, или если у вас в `object` есть значения, которые не подходят для сериализации, то вам следует определить для него метод `toJSON()`, который возвратит *безопасную для JSON* версию `object`.

Например:

```js
var o = { };

var a = {
	b: 42,
	c: o,
	d: function(){}
};

// создадим циклическую ссылку в `a`
o.e = a;

// выдаст ошибку о циклической ссылке
// JSON.stringify( a );

// определим пользовательскую сериализацию в JSON
a.toJSON = function() {
	// при сериализации включать только свойство `b`
	return { b: this.b };
};

JSON.stringify( a ); // "{"b":42}"
```

Это очень распространенное заблуждение, что `toJSON()` должен возвращать строковое представление JSON. Вероятно, это неправильно до тех пор, пока вы не захотите сделать сериализацию самой `string` (обычно такого желания нет!). В действительности `toJSON()` должен возвращать обычное значение (любого подходящего типа), а `JSON.stringify(..)` сам преобразует его в строку.

Другими словами, `toJSON()` следует интерпретировать как "к JSON-безопасному значению, подходящему для превращения в строку", а не "к строке JSON", как ошибочно предполагают многие разработчики.

Рассмотрим:

```js
var a = {
	val: [1,2,3],

	// вероятно, правильно!
	toJSON: function(){
		return this.val.slice( 1 );
	}
};

var b = {
	val: [1,2,3],

	// вероятно, неправильно!
	toJSON: function(){
		return "[" +
			this.val.slice( 1 ).join() +
		"]";
	}
};

JSON.stringify( a ); // "[2,3]"

JSON.stringify( b ); // ""[2,3]""
```

Во втором вызове мы сериализовали возвращаемый `string`, а не `array`, что, вероятно, было не тем, что мы хотели сделать.

Пока мы говорим о `JSON.stringify(..)`, давайте обсудим некоторые менее известные возможности, которые тем не менее могут быть очень полезными.

 В `JSON.stringify(..)` может быть передан необязательный второй аргумент, который называется *replacer*. Он может быть либо `array`, либо `function`. Аргумент используется для настройки рекурсивной сериализации `object`, предоставляя механизм фильтрации, какие свойства должны включаться или исключаться, аналогично тому, как `toJSON()` может готовить значение для сериализации.

Если *replacer* - `array`, то он должен быть массивом строк, каждая из которых будет содержать имя свойства, которое разрешено включать в сериализацию объекта. Если в `object` есть свойство, которого нет в этом списке, оно будет пропущено.

Если *replacer* - `function`, то она будет вызвана один раз для самого `object`, а затем по разу для каждого свойства в `object`. Каждый раз передается два аргумента, *key* (ключ) и *value* (значение). Чтобы пропустить *key* при сериализации, верните значение `undefined`. В противном случае верните указанное *value*.

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"

JSON.stringify( a, function(k,v){
	if (k !== "c") return v;
} );
// "{"b":42,"d":[1,2,3]}"
```

**Примечание:** Когда *replacer* - это `function`, при первом вызове (где передается сам объект `a`) аргумент `k` равен `undefined`. Оператор `if` **отфильтровывает** свойство с именем `"c"`. Строковое преобразование рекурсивное, поэтому в массиве `[1,2,3]` каждое из его значений (`1`, `2`, `3`) передается как аргумент `v`, а индексы (`0`, `1`, `2`) - как аргумент `k`.

В `JSON.stringify(..)` также может быть передан третий необязательный аргумент, называемый *space*, который используется в качестве отступа для более наглядного и читаемого вывода. *space* может быть положительным целым числом, говорящим, сколько пробелов следует использовать на каждом уровне отступа. *space*  может быть и `string`. В этом случае для каждого уровня отступа будут использоваться первые десять символов его значения.

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, null, 3 );
// "{
//    "b": 42,
//    "c": "42",
//    "d": [
//       1,
//       2,
//       3
//    ]
// }"

JSON.stringify( a, null, "-----" );
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------2,
// ----------3
// -----]
// }"
```

Помните, что `JSON.stringify(..)` напрямую не является формой приведения. Однако мы рассмотрели его здесь по двум причинам, которые связывают его действие с приведением `ToString`:

1. Значения `string`, `number`, `boolean` и `null` - все они в основном преобразуются JSON-строки так же, как приводятся в `string`-значения с помощью правил абстрактной операции `ToString`.

2. Если вы передаете `object`-значение в `JSON.stringify(..)`, и в этом `object` есть метод `toJSON()`, то `toJSON()` автоматически вызывается, чтобы (как бы) "привести" значение в *безопасное для JSON значение* перед началом преобразования в строку.

### `ToNumber`

Если любое не `number` значение используется в контексте, требующем, чтобы оно было `number`, например, в математической операции, то спецификация ES5 определяет абстрактную операцию `ToNumber` в разделе 9.3.

Например, `true` становится `1`, `false` - `0`, а `undefined` превращается в `NaN`, но (что любопытно) `null` преобразуется в `0`.

`ToNumber` для `string` значения, по сути, работает по большей части так же, как правила/синтаксис для числовых литералов (см. Главу 3). В случае неудачи, результатом будет `NaN` (вместо синтаксической ошибки, как в случае с `number`-литералами). Один из примеров отличий - в этой операции восьмеричные числа с `0`-префиксом обрабатываются не как восьмеричные (с основанием 8) а, как обычные десятичные числа (с основанием 10), хотя такие восьмеричные являются корректным `number` литералом (см. Главу 2).

**Примечание:** Различия между грамматикой `number`-литерала и `string`-значением в `ToNumber` тонкие и с многими нюансами, поэтому здесь они не будут рассматриваться. Для получения дополнительной информации обратитесь к разделу 9.3.1 спецификации ES5.

Объекты (и массивы) сначала преобразуются в их эквивалент примитивного значения, а результирующее значение (если оно примитив, но еще не `number`) преобразуется в `number` в соответствии с выше описанными правилами `ToNumber`.

Для преобразования в этот эквивалент примитивного значения, абстрактная операция `ToPrimitive` (спецификация ES5, раздел 9.1) использует внутреннюю операцию `DefaultValue` (спецификация ES5, раздел 8.12.8), чтобы определить, есть ли у значения метод `valueOf()`. Если `valueOf()` доступен, и он возвращает примитивное значение, то *это* значение используется для приведения. Если нет, но доступен `toString()`, он обеспечивает значение для приведения.

Если ни одна из операций не может предоставить примитивное значение, выбрасывается ошибка `TypeError`.

Начиная с ES5, вы можете создавать такой неприводимый объект - без `valueOf()` и `toString()` - если его скрытое свойство `[[Prototype]]` равно `null`. Обычно он создаётся с помощью `Object.create(null)`. Обратитесь к книге *This и Прототипы Объектов* из этой же серии для получения дополнительной информации о `[[Prototype]]`.

**Примечание:** Позже в этой главе мы подробно рассмотрим, как приводить `number`, но для следующего фрагмента кода просто предположите, что это выполняет функция `Number(..)`.

Рассмотрим:

```js
var a = {
	valueOf: function(){
		return "42";
	}
};

var b = {
	toString: function(){
		return "42";
	}
};

var c = [4,2];
c.toString = function(){
	return this.join( "" );	// "42"
};

Number( a );			// 42
Number( b );			// 42
Number( c );			// 42
Number( "" );			// 0
Number( [] );			// 0
Number( [ "abc" ] );	// NaN
```

### `ToBoolean`

Далее, давайте немного поговорим о том, как ведут себя `boolean` значения в JS. Вокруг этой темы **много путаницы и неправильных представлений**, так что будьте бдительны!

Прежде всего, в JS есть реальные ключевые слова `true` и `false`, и они ведут себя точно так, как вы ожидаете от `boolean` значений. Распространенное заблуждение, что значения `1` и `0` идентичны `true`/`false`. Хотя это может быть верно для других языков, в JS `number` - это `number`, а `boolean` - это `boolean`. Вы можете привести `1` в `true` (и наоборот) или `0` в `false` (и наоборот). Но это не одно и то же.

#### Ложные значения

Но это еще не конец истории. Нам нужно обсудить, как ведут себя значения, отличные от двух `boolean`, когда вы приводите их *к* `boolean` эквиваленту.

В JavaScript все значения можно разделить на две категории:

1. значения, которые станут `false`, если их привести в `boolean`
2. все остальное (которые, очевидно, станет `true`)

Я не шучу. Спецификация JS определяет конкретный, узкий список значений, которые становятся `false` при приведении в `boolean`.

Как мы узнаем, что это за список значений? В спецификации ES5 раздел 9.2 определяет абстрактную операцию `ToBoolean`, которая точно определяет, что происходит для всех возможных значений, когда вы пытаетесь привести их "к булевому (логическому) значению".

Из этой таблицы мы получаем список так называемых "ложных" значений:

* `undefined`
* `null`
* `false`
* `+0`, `-0` и `NaN`
* `""`

Это он. Если значение находится в этом списке, это "ложное" значение, и оно будет равно `false`, если вы приведёте его к `boolean`.

Согласно логике, если значение *отсутствует* в этом списке, то оно должно быть в *другом списке*, который мы называем списком "правдивых" значений. Но JS спецификация на самом деле не определяет "правдивый" список как таковой. Она приводит отдельные примеры, как, например, явное указание, что все объекты - правдивые. Спецификация просто подразумевает: **все, что явно не указано в списке ложных, является правдивым**.

#### Ложные объекты

Погодите минутку, название этого раздела даже звучит противоречиво. Я буквально *только что сказал*, что спецификация называет все объекты правдивыми, верно? Такого понятия, как "ложный объект", не должно быть.

Что бы это вообще могло значить?

У вас может возникнуть соблазн подумать, что это объект-обертка (см. Главу 3) вокруг ложного значения (такого как `""`, `0` или `false`). Но не попадайтесь на эту *удочку*.

**Примечание:** Это тонкая шутка с уточнением, которую некоторые из вас смогут понять.

Рассмотрим:

```js
var a = new Boolean( false );
var b = new Number( 0 );
var c = new String( "" );
```

Мы знаем, что все три значения здесь являются объектами (см. Главу 3), обернутыми вокруг явно ложных значений. Но ведут ли себя эти объекты как `true` или как `false`? На это легко ответить:

```js
var d = Boolean( a && b && c );

d; // true
```

Итак, все три ведут себя как `true`, ибо только так `d` может оказаться `true`.

**Совет:** Обратите внимание на `Boolean( .. )`, обернутое вокруг выражения `a && b && c` - вы можете задаться вопросом, зачем оно там. Мы вернемся к этому позже, так что запомните это. Для краткости (с точки зрения мелочей) попробуйте узнать сами, каким будет `d`, если вы просто выполните `d = a && b && c` без вызова `Boolean( .. )`!

Итак, если "ложные объекты" - это **не просто объекты, обернутые вокруг ложных значений**, то что же это такое, черт возьми?

Сложность заключается в том, что они могут появляться в вашем JS коде, но на самом деле они не являются частью самого JavaScript.

**Что!?**

Есть конкретные ситуации, когда браузеры изобрели свой вид поведения *экзотических* значений, а именно идею "ложных объектов" поверх обычной семантики JS.

"Ложный объект" - это значение, которое выглядит и действует как обычный объект (свойства и т.д.). Но, когда вы приводите его значение к `boolean`, оно превращается в `false`.

**Почему!?**

Самым известным примером является `document.all`: массивоподобный (объект), предоставляемый вашей JS программе *DOM*-ом (не самим движком JS), который отражает элементы страницы для вашей программы. Он *вёл* себя как обычный объект - действовал бы он правдиво. Но больше это не так.

`document.all` само по себе никогда не было по-настоящему "стандартным" и уже давно признано устаревшим и стало неподдерживаемым.

"Не могут ли они просто удалить это тогда?" Извини, хорошая попытка. Жаль, что они не могут. Существует слишком много старого JS кода, который использует его.

Так, зачем заставлять его действовать ложно? Потому что приведение `document.all` к `boolean` (например, в операторе `if`) почти всегда использовалось как средство обнаружения старого, нестандартного IE.

IE уже давно соответствует стандартам и во многих случаях продвигает веб вперед не меньше, а то и больше, чем любой другой браузер. Но весь этот старый код `if (document.all) { /* это IE */ }` все еще работает, и большая его часть, вероятно, никогда не уйдёт. Всё это наследие из старого кода по-прежнему предполагает, что он работает в IE десятилетней давности, что попросту приводит к некорректной работе страниц у пользователей IE.

Итак, мы не можем удалить `document.all` полностью, но IE не хочет, чтобы код `if (document.all) { .. }` больше работал. Он хочет, чтобы пользователи современного IE получали новую, соответствующую стандартам логику кода.

**"Что нам делать?"** "Я знаю! Давайте уничтожим систему типов JS и притворимся, что `document.all` - ложный!"

Фу. Это отстой. Это сумасшедшая уловка, которую большинство разработчиков JS не понимают. Но альтернатива (ничего не делать с вышеупомянутыми проблемами) - *еще больший отстой*.

Итак... вот что мы имеем: сумасшедшие, нестандартные "ложные объекты", добавленные браузерами в JavaScript. Ура!

#### Правдивые значения

Вернемся к правдивому списку. Какие именно значения правдивые? Помните: **значение правдивое, если его нет в списке ложных**.

Рассмотрим:

```js
var a = "false";
var b = "0";
var c = "''";

var d = Boolean( a && b && c );

d;
```

По вашему мнению, какое значение будет иметь `d` здесь? Это должно быть либо `true`, либо `false`.

Это будет `true`. Почему? Потому что, хотя содержимое этих `string` выглядит как ложные значения, сами `string` значения являются истинными, потому что в списке ложных `string` есть единственное значение - это `""`.

А эти?

```js
var a = [];				// пустой array -- правдивое или ложное?
var b = {};				// пустой object -- правдивое или ложное?
var c = function(){};	// пустая function -- правдивое или ложное?

var d = Boolean( a && b && c );

d;
```

Да, вы уже догадались, `d` здесь по-прежнему `true`. Почему? Та же причина, что и раньше. Несмотря на то, чем это может казаться, `[]`, `{}` и `function(){}` *отсутствуют* в списке ложных значений и, следовательно, являются истинными значениями.

Другими словами, правдивый список бесконечно длинен. Составить такой список невозможно. Вы можете только составить конечный список ложных значений и сверяться *с ним*.

Потратьте пять минут, напишите ложный список на стикере для монитора или запомните его, если хотите. Тогда, вы легко сможете воспроизвести виртуальный правдивый список, когда это вам понадобится, просто спросив, есть ли он в ложном списке или нет.

Важность правдивости и ложности заключается в понимании того, как будет вести себя значение, если вы его приведёте (явно или неявно) к `boolean` значению. Теперь, когда у вас есть эти два списка, мы можем углубиться в примеры приведения.

## Явное приведение

*Явное* приведение относится к преобразованиям типов, которые являются очевидными и явными. Существует широкий спектр применений преобразования типов, которое соответствует категории *явного* приведения у большинства разработчиков.

Цель заключается в том, чтобы выявить в нашем коде шаблоны - ясного и очевидного преобразования значения из одного типа в другой - так, чтобы не оставлять ям, в которые могут угодить будущие разработчики. Чем более демонстративны мы будем, тем больше вероятность, что кто-то после сможет прочитать и понять наш код без излишних усилий, какие у нас были намерения.

Думается, не будет каких-либо существенных разногласий относительно *явного* приведения, поскольку оно наиболее точно соответствует общепринятой практике преобразования типов, сложившейся в языках со статической типизацией. Таким образом, мы примем как должное (на данный момент), что *явное* приведение едино в том, чтобы не быть злонамеренным или противоречивым. Однако мы вернемся к этому позже.

### Явно: Строки <--> Числа

Мы начнем с самой простой и, возможно, наиболее распространенной операции приведения: преобразование значений между  `string` и `number` представлениями.

Для приведения между `string` и `number` мы используем встроенные функции `String(..)` и `Number(..)` (которые мы назвали "собственными конструкторами" в Главе 3), при этом **очень важно**, мы не используем ключевое слово `new` перед ними. Таким образом, мы не создаем объекты-обёртки.

Вместо этого мы на самом деле выполняем *явное приведение* между двумя этими типами:

```js
var a = 42;
var b = String( a );

var c = "3.14";
var d = Number( c );

b; // "42"
d; // 3.14
```

`String(..)` преобразует любое значение в примитивное значение `string`, используя ранее рассмотренные правила операции `ToString`. `Number(..)` преобразует любое значение в примитивное значение `number`, используя ранее описанные правила операции `ToNumber`.

Я называю это *явным* приведением, потому что в целом для большинства разработчиков довольно очевидно, что конечным результатом этих операций является приемлемое преобразование типа.

Действительно, это очень похоже на то, как это работает в некоторых других статически типизированных языках.

Например, в C/C++ вы можете написать либо `(int)x`, либо `int(x)`, и оба они преобразуют значение в `x` в целое число. Обе формы допустимы, но многие предпочитают последнюю, которая выглядит как вызов функции. В JavaScript, когда вы пишете `Number(x)`, это выглядит ужасно похоже. Имеет ли значение, что это *на самом деле* вызов функции в JS? Не совсем.

Помимо `String(..)` и `Number(..)`, существуют другие способы "явного" приведения значений между `string` и `number`:

```js
var a = 42;
var b = a.toString();

var c = "3.14";
var d = +c;

b; // "42"
d; // 3.14
```

Вызов `a.toString()` считается явным (довольно ясно, что "toString" означает "к строке"), но здесь есть определенная скрытая неявность. `toString()` не может быть вызван для *примитивного* значения, такого как `42`. Поэтому JS автоматически "упаковывает" (см. Главу 3) `42` в объект-обёртку, так что `toString()` может быть вызван. Другими словами, вы могли бы назвать это "явно неявным".

`+c` здесь демонстрирует форму *унарного оператора* `+` (оператор только с одним операндом). Однако вместо выполнения математического сложения (или сцепления строк - см. ниже) унарный символ `+` явно приводит свой операнд (`c`) в значение `number`.

Является ли `+c` *явным* приведением? Зависит от вашего опыта и точки зрения. Если вы знаете (а вы теперь знаете!), что унарный `+` явно предназначен для приведения к `number`, то это достаточно явно и очевидно. Однако, если вы никогда не видели этого раньше, это может показаться ужасно запутанным, неявным, со скрытыми побочными эффектами и т.д.

**Примечание:** Общепринятая точка зрения JS-сообщества с открытым исходным кодом заключается в том, что унарный `+` является приемлемой формой *явного* приведения.

Даже если вам действительно нравится форма `+c`, определенно есть места, где она может выглядеть ужасно запутанной. Рассмотрим пример:

```js
var c = "3.14";
var d = 5+ +c;

d; // 8.14
```

Унарный оператор `-` также выполняет приведение, как и `+`, но он ещё меняет знак числа. При этом вы не можете поместить два оператора рядом с друг другом `--`, чтобы отменить смену знака, так как это интерпретируется как оператор уменьшения. Вместо этого вам нужно было бы сделать: `- -"3.14"` с пробелом между ними, тогда бы это вызвало приведение к `3.14`.

Вероятно, вы можете придумать всевозможные отвратительные комбинации двоичных операторов (подобно `+` для сложения) рядом с унарной формой оператора. Вот еще один безумный пример:

```js
1 + - + + + - + 1;	// 2
```

Вам следует настойчиво избегать приведения с унарным `+` (или `-`), когда он примыкает к другим операторам. Хотя пример выше работает, такое почти везде считается плохой идеей. Даже `d = +c` (или `d = + c`, если уж на то пошло!) слишком легко спутать с `d + = c`, что совершенно другое!

**Примечание:** Другим чрезвычайно запутанным случаем использования унарного `+` - это помещение его рядом с операторами инкремента `++` и декремента `--`. Например: `a +++b`, `a + ++b` и `a + + +b`. Больше подробностей о `++` смотрите в разделе "Побочные эффекты выражений" в Главе 5.

Помните, мы пытаемся явно выразить свои намерения и **уменьшить** путаницу, а не усугублять ее!

#### `Date` в `number`

Другим распространенным случаем использования унарного оператора `+` является приведение объекта `Date` в `number`, так как в результате мы получаем метку времени unix (миллисекунды, прошедшие с 1 января 1970 года 00:00:00 UTC), представляющую значение даты/времени:

```js
var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

+d; // 1408369986000
```
Самым распространенным применением этой идиомы является фиксация времени *текущего времени* в виде метки времени, например, так:

```js
var timestamp = +new Date();
```

**Примечание:** Некоторые разработчики знают о специфическом синтаксическом "трюке" в JavaScript, который заключается в том, что `()` при вызове конструктора (функция, вызываемая с `new`), являются *необязательными*, если нет аргументов для передачи. Поэтому, вы можете встретить такой вариант: `var timestamp = +new Date;`. Однако не все разработчики согласны с тем, что отсутствие `()` улучшает читаемость, поскольку это необычное синтаксическое исключение применяется только к форме вызова `new fn()`, а не к обычной форме вызова `fn()`.

Но приведение - это не единственный способ получить метку времени из объекта `Date`. Вариант без приведения, возможно, даже предпочтительнее, поскольку он более явный:

```js
var timestamp = new Date().getTime();
// var timestamp = (new Date()).getTime();
// var timestamp = (new Date).getTime();
```

Но *еще более* предпочтительным вариантом без приведения является использование появившейся в ES5 статической функции `Date.now()`:

```js
var timestamp = Date.now();
```

В старых браузерах вы можете использовать полифил `Date.now()`, он довольно простой:

```js
if (!Date.now) {
	Date.now = function() {
		return +new Date();
	};
}
```

Я бы рекомендовал избегать приведений, связанных с датами. Используйте `Date.now()` для метки времени *текущего момента* и `new Date( .. ).getTime()` для получения метки времени *не текущего момента*, который можно указать в виде даты/времени.

#### Любопытный случай с `~`

Одним из операторов приведения, который часто упускается из виду и обычно сбивает с толку, является оператор тильды `~` ("побитовое НЕ"). Многие из тех, кто даже понимает, что он делает, часто избегают его. Но, придерживаясь духа этой книги и серии, давайте углубимся в него, чтобы выяснить, может ли `~` дать нам что-нибудь полезное.

В разделе "32-битные целые числа (со знаком)" Главы 2 мы писали, что в JS побитовые операторы работают только как 32-разрядные операторы, то есть они требуют от своих операндов иметь значение в 32-разрядном представлении. Правила того, как это происходит, управляется абстрактной операцией `ToInt32` (спецификация ES5, раздел 9.5).

`ToInt32` сначала выполняет приведение `ToNumber`, что означает, что, если значение равно `"123"`, оно сначала станет `123`, прежде чем будут применены правила `ToInt32`.

Хотя *технически* это не приведение (поскольку тип не меняется!), использование побитовых операторов (такого как `|` или `~`) с определенными специальными значениями `number` дает эффект приведения и другое значение `number`.

Например, давайте сначала рассмотрим оператор `|` - "побитовое ИЛИ", используемый в идиоме `0 | x`, которая (как показано в Главе 2) по сути выполняет лишь преобразование `ToInt32`:

```js
0 | -0;			// 0
0 | NaN;		// 0
0 | Infinity;	// 0
0 | -Infinity;	// 0
```

Эти специальные числа нельзя представить в 32-разрядном виде (поскольку они взяты из 64-разрядного стандарта IEEE 754 - см. Главу 2), поэтому `ToInt32` просто указывает `0` как результат этих значений.

Спорно, является ли `0 | __` *явной* формой приведения операции `ToInt32` или она всё же *неявная*. С точки зрения спецификации, она безусловно *явная*, но если вы не понимаете побитовые операции, то она вероятно может показаться *неявной* и волшебной. Тем не менее, в соответствии с другими утверждениями в этой главе, мы будем называть приведение *явным*.

Итак, давайте опять обратим наше внимание на `~`. Оператор `~` сначала "приводит" к 32-разрядному значению `number`, а затем выполняет побитовое отрицание (инвертируя каждый бит).

**Примечание:** Это очень похоже на то, как `!` не только преобразует значение в `boolean`, но и инвертирует его значение (см. обсуждение "унарного `!`" ниже).

Но... что?! Почему нас волнует, что биты инвертируются? Это довольно специфичная тема. JS-разработчикам довольно редко приходится задумываться об отдельных битах.

Иной смысл сущности `~` даёт информатика старой школы / дискретная математика: здесь `~` - это операция дополнения двойки. Отлично, спасибо, это совершенно ясно!

Давайте попробуем еще раз: `~x` примерно совпадает с `-(x+1)`. Это странно, но рассуждать об этом немного легче. Итак:

```js
~42;	// -(42+1) ==> -43
```

Вы, вероятно, все еще задаетесь вопросом, к чему, черт возьми, вся эта ерунда с `~`, или почему это действительно важно в обсуждении приведения? Давайте сразу перейдем к делу.

Рассмотрим `-(x+1)`. Какое единственное значение, с которым вы можете выполнить эту операцию и получить результат `0` (или `-0` технически!)? `-1`. Другими словами, `~`, используемая с разными значениями `number`, даст ложное значение `0` (легко приводимое к `false`) для входного значения `-1`. В любом другом случае мы значение `number` будет правдивым.

Какое отношение это имеет к делу?

`-1` обычно зовётся "контрольным значением" - это значение, которому придается определенный семантический смысл в наборе данных того же типа (`number`). Язык C использует контрольные значения `-1` во многих функциях, которые возвращают значения `>= 0` в случае "успеха" и `-1` для "неудач".

JavaScript заимствовал этот подход для `string` операции `indexOf(..)`, которая ищет подстроку и, если найдена, возвращает ее индекс-позицию или `-1`, если она не найдена.

Довольно часто пытаются использовать `indexOf(..)` не только для поиска позиции, но и как `boolean` проверку наличия/отсутствия подстроки в другой `string`. Вот как обычно выполняют такие проверки:

```js
var a = "Hello World";

if (a.indexOf( "lo" ) >= 0) {	// true
	// нашёл!
}
if (a.indexOf( "lo" ) != -1) {	// true
	// нашёл
}

if (a.indexOf( "ol" ) < 0) {	// true
	// не нашёл!
}
if (a.indexOf( "ol" ) == -1) {	// true
	// не нашёл!
}
```

Я нахожу довольно неэстетичным видеть в коде `>= 0` или `== -1`. По сути, это "дырявая абстракция", поскольку она выставляет наружу, в мой код, свою внутреннюю реализацию - использование контрольного `-1` для "сбоя". Я бы предпочел, чтобы такие детали были скрыты.

Наконец, мы видим, как `~` могла бы нам помочь! Использование `~` с `indexOf()` "приводит" (на самом деле просто преобразует) результат **к значению, которое можно привести к `boolean`**:

```js
var a = "Hello World";

~a.indexOf( "lo" );			// -4   <-- правдивое!

if (~a.indexOf( "lo" )) {	// true
	// нашёл!
}

~a.indexOf( "ol" );			// 0    <-- ложное!
!~a.indexOf( "ol" );		// true

if (!~a.indexOf( "ol" )) {	// true
	// не нашёл!
}
```

`~` принимает возвращаемое значение `indexOf(..)` и преобразует его: для `-1` "сбоя" мы получаем ложный `0`, а все остальные значения являются правдивыми.

**Примечание:** Псевдоалгоритм `-(x + 1)` для `~` подразумевает, что `~-1` равно `-0`, но на самом деле тильда выдает `0`, потому что операция на самом деле побитовая, а не математическая.

Технически, `if (~a.indexOf(..))` использует *неявное* приведение результирующего значения `0` к `false` или ненулевого значения к `true`. Но в целом, мне кажется, `~` больше похожа на *явное* приведение, если вы знаете, цель этого оператора в этой идиоме.

Я считаю, что это более ясный код, чем беспорядок с `>= 0` / `== -1`.

##### Отбрасывание битов

Ещё одно место, где `~` может появиться в коде, с которым вы сталкиваетесь: некоторые разработчики используют двойную тильду `~~`, чтобы отбросить десятичную часть `number` (т.е. "привести" его к целому числу "integer"). Часто утверждается (хотя и ошибочно), что это тот же самое, что и вызов `Math.floor(..)`.

Как работает `~~`: первая `~` выполняет "приведение" `ToInt32`  и побитовую инверсию, затем вторая `~` выполняет еще одно побитовое переключение, возвращая все биты обратно в исходное состояние. Итог - просто "приведение" `ToInt32` (оно же усечение/отбрасывание).

**Примечание:** Побитовая двойная инверсия `~~` очень похожа на действие двойного отрицания `!!`, которое рассматривается ниже в разделе "Явно: * --> Булево значение".

Однако `~~` нуждается в некотором предостережении/разъяснении. Во-первых, он корректно работает только с 32-разрядными значениями. Но что еще более важно, с отрицательными числами она действует не так, как `Math.floor (..)`!

```js
Math.floor( -49.6 );	// -50
~~-49.6;				// -49
```

Оставляя в стороне отличие `Math.floor(..)`, `~~x` усекает до (32-разрядного) целого числа. Но то же самое делает и `x | 0`, и, по-видимому, с (немного) *меньшими усилиями*.

Итак, почему же тогда вы могли бы выбрать `~~x` вместо `x | 0`? Приоритет операторов (см. Главу 5):

```js
~~1E20 / 10;		// 166199296

1E20 | 0 / 10;		// 1661992960
(1E20 | 0) / 10;	// 166199296
```

Как и во всех других советах здесь, используйте `~` и `~~` в качестве явного механизма "приведения" и преобразования значений только в том случае, если каждый, кто читает/пишет такой код, в курсе, как работают эти операторы! 

### Явно: Парсинг числовых строк

Аналогичный приведению `string` к `number` результат можно получить путем выявления чисел в символах строки. Однако есть явные различия между таким парсингом и преобразованием типов, рассмотренным ранее.

Взгляните:

```js
var a = "42";
var b = "42px";

Number( a );	// 42
parseInt( a );	// 42

Number( b );	// NaN
parseInt( b );	// 42
```

Парсинг числового значения из строки *терпим* к нечисловым символам - он просто прекращает синтаксический анализ слева направо при их обнаружении. Приведение же *не терпимо* и приводит к значению `NaN`.

Парсинг не следует рассматривать как замену приведению. Эти две задачи, хотя и схожи, имеют разные цели. Разбирайте `string` как `number`, когда вы не знаете / неважно, появятся ли нечисловые символы с правой стороны. Приводите `string` (к `number`), когда допустимы лишь числовые значения, а что-то вроде `"42px"` должно быть отклонено.

**Совет:** `parseInt(..)` имеет двойника, `parseFloat(..)`, который (как понятно) извлекает из строки число с плавающей запятой.

Не забывайте, что `parseInt(..)` работает со значениями `string`. Нет абсолютно никакого смысла передавать значение `number` в `parseInt(..)`. Также не имеет смысла передавать значение любого другого типа, например, `true`, `function(){..}` или `[1,2,3]`.

Если вы передаете значение, отличное от `string`, то оно сначала автоматически приводится в `string` (см. "`ToString`" выше), что очевидно своего рода скрытое *неявное* приведение. Это действительно плохая идея полагаться на такое поведение в вашей программе, поэтому никогда не используйте `parseInt(..)` со значением, отличным от `string`.

До ES5 была другая ошибка с `parseInt(..)`, которая служила источником ошибок во многих программах на JS. Если вы не передавали второй аргумент (radix), чтобы обозначить, какую систему счисления использовать для интерпретации строки, `parseInt(..)` анализировала первые символы строки и делала предположения.

Если первые два символа `"0x"` или `"0X"`, предполагалось (по соглашению), что вы хотели интерпретировать `string` как шестнадцатеричное `number` (основание - 16). Иначе, если первый символ `"0"`, предполагалось (опять же, по соглашению), что вы хотели интерпретировать `string` как восьмеричное `number` (основание - 8).

Шестнадцатеричную строку (с начальным значением `0x` или `0X`) не так-то просто перепутать. Но угадывание восьмеричных чисел оказалось дьявольским явлением. Например:

```js
var hour = parseInt( selectedHour.value );
var minute = parseInt( selectedMinute.value );

console.log( "The time you selected was: " + hour + ":" + minute);
```

Выглядит безобидным, правда? Попробуйте взять `08` для часа и `09` для минуты. Вы получите `0:0`. Почему? потому что ни `8`, ни `9` не являются допустимыми символами в восьмеричной системе.

До ES5 заплатка была простой, но её так легко забыть: **всегда передавайте `10` в качестве второго аргумента**. Это было абсолютно безопасно:

```js
var hour = parseInt( selectedHour.value, 10 );
var minute = parseInt( selectedMiniute.value, 10 );
```

Начиная с ES5, `parseInt(..)` больше не угадывает восьмеричные числа. Если вы не скажете обратное, он предполагает базу - 10 (или базу - 16 для префиксов `"0x"`). Это гораздо приятнее. Просто будьте осторожны, если ваш код должен выполняться в окружении до ES5.В этом случае вам нужно передать `10` в radix (основание).

#### Парсинг не строк

Один печально известный пример поведения `parseInt(..)` был опубликован в саркастически-шутливом посте несколько лет назад:

```js
parseInt( 1/0, 19 ); // 18
```

Предположительное (но совершенно неверное) утверждение гласило: "Если я передам Infinity и разберу её в целое число, то я должен получить Infinity, а не 18". Вероятно, JS совсем без ума раз дает такой результат, верно?

Хотя этот пример явно надуман и нереален, давайте на мгновение предадимся безумию и посмотрим, действительно ли JS настолько дурацкий.

Во-первых, самый очевидный грех, совершенный здесь, заключается в передаче не-`string` в `parseInt(..)`. Этого не должно быть. Делая так, ты напрашиваешься на неприятности. Но даже совершая такое, JS вежливо приведет то, что вы передаете, в `string`, которую он затем может попытаться распарсить.

Некоторые могут возразить, что это неоправданное поведение, и что `parseInt(..)` должен отказаться работать со значением, отличным от `string`. Возможно, это должно выдавать ошибку? Честно говоря, это было бы очень похоже на Java. Я содрогаюсь при мысли, что JS должен начать выдавать ошибки повсюду, так что `try..catch` требуется почти в каждой строке.

Должен ли он возвращать `NaN`? Может быть. Но... как насчет:

```js
parseInt( new String( "42") );
```

Потерпит ли это тоже неудачу? Это значение, отличное от `string`. Если вы хотите, чтобы объект-обёртка `String` был распакован в `"42"`, то действительно ли так необычно, что `42` сначала становится `"42"`, чтобы потом превратиться в `42`?

Я бы сказал, что это наполовину *явное* и наполовину *неявное* приведение, которое может иметь место, и может быть очень полезным. Например:

```js
var a = {
	num: 21,
	toString: function() { return String( this.num * 2 ); }
};

parseInt( a ); // 42
```

Тот, что `parseInt(..)` принудительно приводит значение к `string` перед парсингом, вполне разумно. Если вы кладёте мусор и вынимаете его обратно, не вините мусорное ведро - оно просто добросовестно выполняло свою работу.

Итак, если вы передаете значение типа `Infinity` (очевидный результат `1 / 0`), какое `string`-представление имеет наибольший смысл для его дальнейшего приведения? На ум приходят только два разумных варианта: `"Infinity"` и `"∞"`. JS выбрал `"Infinity"` и я рад, что он так поступил.

Я думаю, это хорошо, что **все значения** в JS имеют какое-то `string` представление по умолчанию, поэтому они не таинственные черные ящики, которые мы не можем отлаживать и анализировать их.

Хорошо, что насчет основания 19? Очевидно, совершенно фальшивая и надуманная. Никакие реальные JS-программы не используют основание 19. Это абсурд. Но опять же, давайте предадимся нелепице. В системе с основанием 19 допустимыми числовыми символами являются `0` - `9` и `a` - `i` (без учета регистра).

Итак, вернемся к нашему примеру `parseInt( 1/0, 19 )`. По сути, это `parseInt( "Infinity", 19 )`. Как это анализируется? Первый символ - `"I"` - в глупой девятнадцатеричной системе имеет значение `18`. Второй символ `"n"` в допустимом наборе числовых символов отсутствует, и поэтому анализ просто вежливо останавливается, точно так же, как когда он наткнулся на `"p"` в `"42px"`.

Результат? `18`. Получилось именно так, как и должно быть. Логика привела нас сюда, а не к ошибке или к `Infinity`, что **очень важно** для JS, и поэтому его не следует так легко отбрасывать.

Приведём ещё примеры такого поведения `parseInt(..)`, которые могут показаться удивительными, но которые вполне разумные:

```js
parseInt( 0.000008 );		// 0   ("0" из "0.000008")
parseInt( 0.0000008 );		// 8   ("8" из "8e-7")
parseInt( false, 16 );		// 250 ("fa" из "false")
parseInt( parseInt, 16 );	// 15  ("f" из "function..")

parseInt( "0x10" );			// 16
parseInt( "103", 2 );		// 2
```

`parseInt(..)` на самом деле довольно предсказуем и последователен в своем поведении. Если вы будете использовать его правильно, вы получите разумные результаты. Если вы используете его неправильно, сумасшедшие результаты, которые вы получаете, не являются ошибкой JavaScript.

### Явно: * --> Булево значение

Теперь давайте рассмотрим приведение любого значения, не являющегося `boolean`, к `boolean`.

Точно так же, как со `String(..)` и `Number(..)` выше, `Boolean(..)` (без `new`, конечно!) - это явный способ приведения `ToBoolean`.:

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

Boolean( a ); // true
Boolean( b ); // true
Boolean( c ); // true

Boolean( d ); // false
Boolean( e ); // false
Boolean( f ); // false
Boolean( g ); // false
```

Хотя `Boolean (..)` явно выражает намерение, он мало распространен или не идиоматичен.

Точно так же, как унарный оператор `+` преобразует значение в `number` (см. выше), унарный оператор отрицания `!` явно преобразует значение в `boolean`. *Проблема* заключается в том, что он также меняет значение с истинного на ложное или наоборот. Поэтому, самый популярный способ явного приведения к `boolean`, к которому прибегают JS разработчики, - это оператор двойного отрицания `!!`. В нём второй `!` вернет исходный `true`/`false`:

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

!!a;	// true
!!b;	// true
!!c;	// true

!!d;	// false
!!e;	// false
!!f;	// false
!!g;	// false
```

Любое приведение `ToBoolean` выполняется *неявно* без `Boolean(..)` или `!!`, если используется в `boolean` контексте, таком как оператор `if (..) ..`. Но наша цель - это явное приведение значения к `boolean`, чтобы было понятно, что мы используем намеренное приведение `ToBoolean`.

Другой пример использования явного приведения `ToBoolean` - это, когда вы хотите выполнить приведение к `true`/`false` при сериализации структуры данных в формате JSON:

```js
var a = [
	1,
	function(){ /*..*/ },
	2,
	function(){ /*..*/ }
];

JSON.stringify( a ); // "[1,null,2,null]"

JSON.stringify( a, function(key,val){
	if (typeof val == "function") {
		// выполнить приведение `ToBoolean` для функции
		return !!val;
	}
	else {
		return val;
	}
} );
// "[1,true,2,true]"
```

Если вы пришли в JavaScript из Java, вы можете узнать эту идиому:

```js
var a = 42;

var b = a ? true : false;
```

Тернарный оператор `? :` проверит `a` на правдивость и на основе этого присвоит `b` либо `true`, либо `false`.

На первый взгляд эта идиома выглядит как форма *явного* приведения `ToBoolean`, поскольку, очевидно, операция выдает `true` или `false`.

Однако присутствует скрытое *неявное* приведение, заключающееся в том, что выражение `a` сначала должно быть приведено в `boolean` для прохождения теста на правдивость. Я бы назвал эту идиому "явно неявной". Кроме того, я бы посоветовал вам **всегда избегайте эту идиому** в JavaScript. Это не дает никакой пользы, но, что куда хуже, выдает себя за то, чем оно не является.

`Boolean(a)` и `!!a` намного лучше в качестве *явных* вариантов приведения.

## Неявное приведение

*Неявное* приведение относится к скрытым преобразованиям типов с неочевидными побочными эффектами, которые неявно возникают в результате других действий. Другими словами, *неявные приведения* - это любые преобразования типов, которые не очевидны (для вас).

Если цель *явного* приведения ясна (сделать код однозначным и более понятным), то также понятно, что *неявное* приведение преследует противоположную цель: усложнить понимание кода.

Если принять всё за чистую монету, то, я полагаю, это источник большей части гнева по отношению к приведению. Большинство жалоб на "приведение JavaScript" на самом деле касаются (осознано или нет) *неявного* приведения.

**Примечание:** Дуглас Крокфорд, автор книги *"JavaScript: сильные стороны"*, утверждал во многих выступлениях на конференциях и в статьях, что следует избегать приведения в JavaScript. Но что он, по-видимому, имеет в виду, так это то, что *неявное* приведение - это плохо (по его мнению). Однако, если вы прочтете его собственный код, вы найдете множество примеров приведения, как *неявного*, так и *явного*! По правде говоря, его беспокойство, похоже, в первую очередь направлено на операцию `==`, но, как вы увидите в этой главе, это только часть механизма приведения.

Итак, **является ли скрытое приведение** злом? Это опасно? Является ли это недостатком в дизайне JavaScript? Должны ли мы избегать этого любой ценой?

Бьюсь об заклад, большинство из вас, читатели, склонны с энтузиазмом воскликнуть: "Да!"

**Не так быстро**. Выслушай меня.

Давайте взглянем с другой точки зрения на то, что такое *неявное* приведение и каким оно может быть, а не просто заявить, что оно "противоположность хорошему явному виду приведения". Это слишком узко и упускает важный нюанс.

Давайте определим цель *неявного* приведения как: уменьшить многословие, шаблонность и/или ненужные детали реализации, которые загрязняют наш код шумом, отвлекающим от более важной цели.

### Упрощение неявного

Прежде чем мы перейдем к JavaScript, позвольте мне предложить что-нибудь псевдокодовое из какого-нибудь теоретического строго типизированного языка для иллюстрации:

```js
SomeType x = SomeType( AnotherType( y ) )
```

В этом примере у меня есть некоторый произвольный тип значения в `y`, который я хочу преобразовать в тип `SomeType`. Проблема в том, что этот язык не может перейти непосредственно от того, чем в данный момент является `y`, к `SomeType`. Ему нужен промежуточный шаг, на котором он сначала преобразуется в `AnotherType`, а затем из `AnotherType` в `SomeType`.

Теперь, что, если бы этот язык просто позволил вам написать:

```js
SomeType x = SomeType( y )
```

Разве вы в целом не согласились бы с тем, что мы упростили преобразование типов, чтобы уменьшить ненужный "шум" промежуточного этапа преобразования? Я имею в виду, *действительно* ли так важно, прямо здесь, на этом этапе кода, увидеть и смириться с тем фактом, что `y` сначала переходит в `AnotherType`, а затем в `SomeType`? 

Кто-то мог бы возразить, что, по крайней мере, при некоторых обстоятельствах, да. Но я думаю, что во многих других обстоятельствах можно привести равный аргумент в пользу того, что здесь упрощение **на самом деле способствует удобочитаемости кода** путем абстрагирования или сокрытия таких деталей в самом ли языке, или в наших собственных абстракциях.

Несомненно, где-то за кулисами все еще происходит промежуточный этап преобразования. Но если здесь эта деталь скрыта от глаз, мы можем просто рассуждать о том, что преобразуем `y` в `SomeType` в виде стандартной операции, скрывая ненужные детали.

Хотя это и не идеальная аналогия, я собираюсь утверждать на протяжении всей остальной части этой главы, что *неявное* приведение JS можно рассматривать как оказание аналогичной помощи вашему коду.

Но, **и это очень важно**, это не безграничное, абсолютное утверждение. Определенно, вокруг *неявного* приведения скрывается множество *пороков*, которые нанесут вашему коду гораздо больший вред, чем любые потенциальные улучшения читаемости. Очевидно, что мы должны научиться избегать таких конструкций, чтобы не отравлять наш код всевозможными ошибками.

Многие разработчики считают, что если механизм может делать какую-то полезную вещь **A**, но также может быть использован не по назначению для совершения какой-то ужасной вещи **Z**, то мы должны полностью отказаться от него, просто на всякий случай.

Мой совет вам таков: не соглашайтесь на это. Не "выплескивайте ребенка вместе с водой". Не думайте, что *неявное* приведение - это плохо, потому что все, что, по вашему мнению, вы когда-либо видели, - это его "плохие стороны". Я думаю, что здесь есть "сильные стороны", и я хочу помочь и вдохновить большинство из вас найти и принять их!

### Неявно: Строки <--> Числа

Ранее в этой главе мы исследовали *явное* приведение между значениями `string` и `number`. Теперь давайте рассмотрим ту же задачу, но с использованием методов *неявного* приведения. Но прежде чем мы это сделаем, мы должны изучить некоторые нюансы операций, которые *неявно* приведут к приведению.

Оператор `+` очень занятой. Он и складывает `number`, и сцепляет `string`. Итак, как JS догадывается, какой тип операции вы хотите использовать? Взгляните:

```js
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b; // "420"
c + d; // 42
```

Где та разница, которая формирует либо `"420"`, либо `42`? Распространенное заблуждение, что разница в том, является ли один или оба операнда `string`, поскольку это означает, что `+` предполагает сцепление `string`. Хотя это отчасти верно, но все гораздо сложнее.

Рассмотрим:

```js
var a = [1,2];
var b = [3,4];

a + b; // "1,23,4"
```

Ни один из этих операндов не является `string`, но очевидно, что они оба были приведены к `string`, а затем произошло сцепление `string`. Так что же происходит на самом деле?

(**Предупреждение:** грядет очень подробный разбор спецификации, так что пропустите следующие два абзаца, если это вас пугает!)

-----

Согласно разделу 11.6.1 спецификации ES5, алгоритм `+` (когда `object`-значение является операндом) будет сцеплять, если любой из операндов либо уже является `string`, либо если следующие шаги ведут к `string`. Итак, когда `+` получает `object` (включая `array`) для любого из операндов, он для значения сначала вызывает абстрактную операцию `ToPrimitive` (раздел 9.1), которая затем вызывает алгоритм `[[DefaultValue]]` (раздел 8.12.8) с контекстной подсказкой `number`.

Если вы будете внимательны, то заметите, что эта операция теперь идентична тому, как абстрактная операция `ToNumber` обрабатывает `object` (см. раздел "`ToNumber`"" выше). Операция `value Of()` над `array` не приведет к созданию простого примитива, поэтому затем он переходит к `toString()`. Так, два массива становятся `"1,2"` и `"3,4"` соответственно. Теперь `+` сцепляет две `string` так, как вы ожидаете: `"1,23,4"`.

-----

Давайте оставим в стороне эти запутанные детали и вернемся к более раннему, упрощенному объяснению: если любой из операндов `+` является `string` (или становится таковым с помощью описанных выше шагов!), операция будет сцеплением `string`. В противном случае это всегда числовое сложение.

**Примечание:** Часто цитируемый пример приведения - `[] + {}` против `{} + []`, которые приводят, соответственно, к `"[object Object]"` и `0`. Однако это еще не все, и мы рассмотрим эти детали в разделе "Блоки" в Главе 5.

Что это значит для *неявного* приведения?

Вы можете привести `number` к `string`, просто "добавив" `number` и `""` - пустую `string`:

```js
var a = 42;
var b = a + "";

b; // "42"
```

**Совет:** Числовое сложение с помощью оператора `+` является коммутативным, что означает, что `2 + 3` совпадает с `3 + 2`. Объединение строк с помощью `+`, очевидно, обычно не является коммутативным, **но** в конкретном случае `""` оно эффективно коммутативно, так как `a + ""` и `"" + a` приведут к одному и тому же результату.

Чрезвычайно популярно / идиоматично (*неявно *) приводить `number` к `string` с помощью операции `+ ""`. Интересно, что даже некоторые из самых ярых критиков *неявного* приведения все еще используют этот подход в своем собственном коде вместо одной из его *явных* альтернатив.

**Я думаю, что это отличный пример** полезной формы в *неявном* приведении, несмотря на то, как часто этот способ подвергается критике!

Сравнивая *неявное* приведение `a + ""` с предыдущим примером *явного* приведения `String(a)`, необходимо учитывать еще одну особенность. Следуя логике работы абстрактной операции `ToPrimitive`, сначала `a + ""` вызывает `valueOf()` для значения `a`, затем возвращаемое значение преобразуется в `string` с помощью внутренней абстрактной операции `ToString`. В то же время `String(a)` просто вызывает `toString()` напрямую.

Оба способа в конечном итоге приводят к `string`, но если вы используете `object` вместо обычного примитивного `number`, вы не обязательно можете получить *такое же* значение `string`!

Рассмотрим:

```js
var a = {
	valueOf: function() { return 42; },
	toString: function() { return 4; }
};

a + "";			// "42"

String( a );	// "4"
```

Как правило, такого рода уловки вам не вредят, если вы только действительно не пытаетесь создавать запутанные структуры данных и методы, но вам следует быть осторожным, если вы пишете свои собственные методы `valueOf()` и `toString()` для какого-то `object`, поскольку то, как вы приводите значение, может повлиять на результат.

А как насчет другого направления? Как мы можем *неявно привести* из `string` в `number`?

```js
var a = "3.14";
var b = a - 0;

b; // 3.14
```

Оператор `-` определен только для числового вычитания, поэтому `a - 0` вызывает приведение значения `a` к `number`. Куда менее распространенные, `a * 1` и `a / 1` также приводят к тому же результату, ибо эти операторы предназначены только для числовых операций.

Как насчет значений `object` с оператором `-`? Аналогичная история, как и для `+` выше:

```js
var a = [3];
var b = [1];

a - b; // 2
```

Оба значения `array` должны стать `number`, но сначала они преобразуются в `strings` (с использованием ожидаемой сериализации `toString()`), а затем преобразуются в `number` для выполнения вычитания `-`.

Итак, является ли *неявное* приведение к `string` и `number` тем уродливым злом, о котором вы слышите в страшилках? Лично я так не думаю.

Сравните `b = String(a)` (*явный*) с `b = a + ""` (*неявный*). Я думаю, что можно привести примеры того, что оба подхода полезны в вашем коде. Конечно, `b = a + ""` немного чаще встречается в JS программах, демонстрируя свою полезность, невзирая на *чувства* по поводу достоинств или опасностей *неявного* приведения в целом.

### Неявно: Булевы значения --> Числа

По-моему, ситуация, когда *неявное* приведение может проявить свои лучшие стороны, - это случай упрощения определенных типов сложной `boolean` логики в виде простого числового сложения. Конечно, это не техника общего назначения, а конкретное решение для особых случаев.

Рассмотрим:

```js
function onlyOne(a,b,c) {
	return !!((a && !b && !c) ||
		(!a && b && !c) || (!a && !b && c));
}

var a = true;
var b = false;

onlyOne( a, b, b );	// true
onlyOne( b, a, b );	// true

onlyOne( a, b, a );	// false
```

Функция `onlyOne(..)` должна возвращать `true` только в том случае, если лишь один из её аргументов является `true` / правдивым. Она использует *неявное* приведение в проверках на правдивость и *явное* приведение в остальных случаях, включая возвращаемое итоговое значение.

Но что, если нам нужно, чтобы эта утилита могла обрабатывать четыре, пять или двадцать флагов одним и тем же способом? Довольно сложно представить реализацию кода, который обрабатывал бы все эти перестановки сравнений.

Вот где приведение `boolean` значений к `number` (очевидно, `0` или `1`) может сильно помочь:

```js
function onlyOne() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
        // пропускаем ложные значения,
		// считая их 0, но избегайте NaN.
		if (arguments[i]) {
			sum += arguments[i];
		}
	}
	return sum == 1;
}

var a = true;
var b = false;

onlyOne( b, a );				// true
onlyOne( b, a, b, b, b );		// true

onlyOne( b, b );				// false
onlyOne( b, a, b, b, b, a );	// false
```

**Примечание:** Конечно, вместо цикла `for` в `onlyOne(..)` вы могли бы более лаконично использовать функцию ES5 `reduce(..)`, но я не хотел затуманивать концепцию.

То, что мы здесь делаем, - это полагаемся на `1` для `true`/правдивых приведений и численно складываем их. `sum + = arguments[i]` использует *неявное* приведение, чтобы это произошло. Если одно и только одно значение в списке `arguments` равно `true`, то числовая сумма будет равна `1`, в противном случае сумма не будет равна `1` и, таким образом, желаемое условие не выполняется.

Конечно, мы могли бы сделать тоже самое с помощью *явного* приведения:

```js
function onlyOne() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
		sum += Number( !!arguments[i] );
	}
	return sum === 1;
}
```

Мы сначала используем `!!arguments[i]`, побуждая привести значения к `true` или `false`. Это для того, чтобы вы могли передавать значения, отличные от `boolean`, например, `onlyOne( "42", 0 )`, и утилита работала бы так, как ожидается (в противном случае вы получили бы сцепление `string`, и логика была бы неверной).

После того, как мы чётко знаем, что это `boolean`, мы выполняем еще одно *явное* приведение с помощью `Number(..)`, чтобы получить `0` или `1`.

Является ли *явная* форма приведения в этой утилите "лучше"? Она позволяет избежать ловушки `NaN`, как описано в комментариях к коду. Но, в конечном счете, это зависит от ваших потребностей. Лично я считаю, что первая версия, опирающаяся на *неявное* приведение, более элегантна (если вы не будете передавать `undefined` или `NaN`), а *явная* версия излишне многословна.

Но, как и почти во всем, то, что мы здесь обсуждаем, это субъективные решения.

**Примечание:** Независимо от подхода, *явного* или *неявного*, вы можете легко создать варианты `onlyTwo(..)` или `onlyFive(..)`, просто изменив итоговое сравнение с `1` на `2` или `5` соответственно. Это значительно проще, чем добавлять кучу выражений `&&` и `||`. Так что, в общем, приведение в данном случае очень полезно.

### Неявно: * --> Булево значение

Теперь давайте обратим наше внимание на *неявное* приведение к `boolean` значениям, поскольку оно, безусловно, самое распространенное, а также всё ещё самое потенциально проблемное.

Помните, *неявное* приведение - это то, что возникает, когда вы используете значение так, что приходится преобразовать значение. Для `number` и `string` операций довольно легко увидеть ситуации вынужденного приведения.

Но какие операции требуют/заставляют (*неявно*) приводить к `boolean`?

1. Проверяемое выражение в операторе `if (..)`.
2. Проверяемое выражение (второе) в `for ( .. ; .. ; .. )`.
3. Проверяемое выражение в циклах `while (..)` и `do..while(..)`.
4. Проверяемое выражение (первое) в тернарном операторе `? :`.
5. Левый операнд (является проверяемым выражением - см. ниже!) в операторах `||` ("логическое или") и `&&` ("логическое и").

Любое значение, используемое в этих контекстах, которое еще не является `boolean`, будет *неявно* преобразовано в `boolean` с использованием правил абстрактной операции `ToBoolean`, рассмотренной выше в этой главе.

Давайте взглянем на примеры:

```js
var a = 42;
var b = "abc";
var c;
var d = null;

if (a) {
	console.log( "угу" );		// угу
}

while (c) {
	console.log( "нет, никогда не выполнится" );
}

c = d ? a : b;
c;								// "abc"

if ((a && d) || c) {
	console.log( "угу" );		// угу
}
```

Во всех этих контекстах значения, не являющиеся `boolean`, *неявно приводятся* к их `boolean` эквивалентам для выполнения проверки.

### Операторы `||` и `&&`

Вероятно, вы видели операторы `||` ("логическое или") и `&&` ("логическое и") в большинстве или во всех других языках, которые вы использовали. Поэтому было бы естественно предположить, что в JavaScript они работают в основном так же, как и в других подобных языках.

Есть очень малоизвестный, но очень важный нюанс.

На самом деле, я бы сказал, что эти операторы даже не следует называть "логическими ___ операторами", поскольку такое название неполно описывает то, что они делают. Если бы я давал им более точное (хотя и более неуклюжее) название, я бы назвал их "операторами выбора" или, более полно, "операторами выбора операндов".

Почему? Потому что в JavaScript они на самом деле не приводят к *логическому* значению (`boolean`), как это происходит в некоторых других языках.

Так, к чему *они* приводят? Они приводят к значению одного (и только одного) из их двух операндов. Другими словами, **они выбирают одно из  значений двух операндов**.

Цитирую раздел 11.11 спецификации ES5:

> Значение, создаваемое оператором && или ||, не обязательно имеет тип Boolean. Полученное значение всегда будет значением одного из выражений двух операндов.

Давайте проиллюстрирую:

```js
var a = 42;
var b = "abc";
var c = null;

a || b;		// 42
a && b;		// "abc"

c || b;		// "abc"
c && b;		// null
```

**Подождите, что!?** Подумайте об этом. В таких языках, как C и PHP, эти выражения приводят к `true` или `false`, но в JS (и Python, и Ruby, если уж на то пошло!) результат определяется самими значениями.

Оба оператора `||` и `&&` выполняют `boolean` тест для **первого операнда** (`a` или `c`). Если операнд еще не является `boolean` (а здесь это не так), происходит обычное приведение `ToBoolean`, и проверка может быть выполнена.

Для оператора `||`, если итог проверки `true`, выражение `||` возвращает значение *первого операнда* (`a` или `c`). Если итог проверки `false`, выражение `||` возвращает значение *второго операнда* (`b`).

И наоборот для оператора `&&`. Если итог проверки `true`, выражение `&&` возвращает значение *второго операнда* (`b`). Если итог проверки `false`, выражение `&&` возвращает значение *первого операнда* (`a` или `c`).

Результатом выражения `||` или `&&` всегда является значение одного из операндов, **а не** результат проверки (возможно, приведенный). В `c && b`, `c` равно `null` и, следовательно, является ложным. Но само выражение `&&` возвращает `null` (значение `c`), а не приведённый `false`, использованный при проверке.

Теперь вы понимаете, что эти операторы действуют как "селекторы операндов"?

Другой взгляд на эти операторы:

```js
a || b;
// примерно эквивалентно:
a ? a : b;

a && b;
// примерно эквивалентно:
a ? b : a;
```

**Примечание:** Я говорю `a || b` "примерно эквивалентно" `a ? a : b` потому что результат идентичен, но есть определённая разница. В `а ? a : b`, если бы `a` было более сложным выражением (например, которое могло бы иметь побочные эффекты, такие как вызов `function` и т.д.), то выражение `a`, возможно, было бы вычислено дважды (если первая оценка была правдивой). В `a || b`, напротив, выражение `a` вычисляется лишь один раз, а это значение используется и для проверки, и в качестве результата (если требуется). Тот же нюанс и в выражениях `a && b` и `a ? b : a`.

Чрезвычайно распространенным и полезным применением данного поведения, которое вы, вероятно, уже использовали и не до конца поняли, следующее:

```js
function foo(a,b) {
	a = a || "hello";
	b = b || "world";

	console.log( a + " " + b );
}

foo();					// "hello world"
foo( "yeah", "yeah!" );	// "yeah yeah!"
```

Идиома `a = a || "hello"` (иногда говорят, что это JavaScript-версия "оператора нулевого слияния" из C#) проверяет `a` и, если у переменной нет значения (или оно нежелательное ложное), то возвращает резервное значение по умолчанию (`"hello"`).

Но **будь осторожен**!

```js
foo( "That's it!", "" ); // "That's it! world" <-- Ой!
```

Видите проблему? `""` во втором аргументе - это ложное значение (см. `ToBoolean` ранее в этой главе). Поэтому проверка в `b = b || "world"` терпит неудачу и замещается значением по умолчанию `"world"`, хотя цель, вероятно, состояла в том, чтобы явно переданная пустая строка `""` была присвоена `b`.

Эта идиома `||` чрезвычайно распространена и весьма полезна, но вы должны использовать ее только в тех случаях, когда *все ложные значения* должны быть проигнорированы. В противном случае вам следует быть более точным в своей проверке и, возможно, прибегнуть к тернарному оператору `? :`.

Эта идиома *присвоения значения по умолчанию* настолько распространена (и полезна!), что даже те, кто публично и яростно осуждает приведение в JavaScript, часто используют ее в своем собственном коде!

А как насчет `&&`?

Есть еще одна идиома, которая несколько реже создается вручную, но которая часто используется JS минификаторами. Оператор `&&` "выбирает" второй операнд тогда и только тогда, когда первый операнд признаётся правдивым, и этот подход иногда называют "защитным оператором" (также см. "Короткое замыкание" в Главе 5) - проверка первого выражения "защищает" второе выражение:

```js
function foo() {
	console.log( a );
}

var a = 42;

a && foo(); // 42
```

`foo()` вызывается только потому, что `a` определяется, как правдивый. Если результат проверки ложный, то выполнение оператора в выражении `a && foo()` молча остановится - это называют "коротким замыканием" - и `foo()` никогда не будет вызван.

Опять же, люди не так часто пишут подобные вещи. Обычно вместо этого они выбирают `if (a) { foo(); }`. Но минификаторы JS предпочитают `a && foo()`, потому что это намного короче. Итак, теперь, если вам когда-нибудь придется расшифровывать такой код, вы будете знать, что он делает и почему.

Хорошо, итак, у `||` и `&&` есть несколько изящных трюков в рукаве, если вы готовы допустить *неявное* приведение в своей работе.

**Примечание:** Обе идиомы `a = b || "something"` и `a && b()` опираются на короткое замыкание, которое мы более подробно рассмотрим в Главе 5.

Тот факт, что эти операторы на самом деле не приводят к `true` и `false`, возможно, уже немного заморочил вам голову. И вы, вероятно, удивляетесь, как вообще работали все ваши операторы `if` и циклы `for`, если в них были сложносоставные логические выражения, такие как `a && (b || c)`.

Не волнуйся! Мир не рушится. С вашим кодом (возможно) всё хорошо. Просто вы, наверное, никогда раньше не осознавали, что **после того, как** было вычислено составное выражение, происходило *неявное* приведение к `boolean`.

Взгляните:

```js
var a = 42;
var b = null;
var c = "foo";

if (a && (b || c)) {
	console.log( "yep" );
}
```

Этот код по-прежнему работает так, как вы всегда думали, за исключением одной незначительной дополнительной детали. Выражение `a && (b || c)` *на самом деле* возвращает `"foo"`, а не `true`. Итак, оператор `if` *затем* приводит значение `foo` к `boolean`, которое, конечно же, будет `true`.

Видите? Нет причин для паники. Ваш код, вероятно, все еще в безопасности. Но теперь вы знаете больше о том, как он делает то, что делает.

И теперь вы также понимаете, что такой код использует *неявное* приведение. Если вы все еще в лагере "избегайте (неявного) приведения", вам нужно будет вернуться к своему коду и сделать все эти проверки *явными*:

```js
if (!!a && (!!b || !!c)) {
	console.log( "yep" );
}
```

Удачи вам в этом! ... Извините, просто подтруниваю.

### Приведение Symbol

До сего момента не было почти никакой заметной разницы в результатах между *явным* и *неявным* приведением - на кону была только читаемость кода.

Но Symbol из ES6 вносят подвох в систему приведения, который нам нужно кратко обсудить. По причинам, которые выходят далеко за рамки того, что мы обсуждаем в этой книге, допускается *явное* преобразование `symbol` в `string`, но *неявное* приведение того же самого запрещено и выкидывает ошибку.

Рассмотрим:

```js
var s1 = Symbol( "cool" );
String( s1 );					// "Symbol(cool)"

var s2 = Symbol( "not cool" );
s2 + "";						// TypeError
```

Значения `symbol` вообще нельзя привести к `number` (всегда выдает ошибку), но, как ни странно, их можно как *явно*, так и *неявно* приводить к `boolean` (всегда `true`).

Согласованной системе всегда легче научиться, а с исключениями всегда невесело иметь дело. Нам просто нужно быть осторожными с новыми `symbol` из ES6 и с тем, как их приводить.

Хорошая новость: вероятно, вам крайне редко понадобится приводить значение `symbol`. То, как они обычно используются (см. Главу 3), не требует их приведения на постоянной основе.

## Loose Equals vs. Strict Equals

Loose equals is the `==` operator, and strict equals is the `===` operator. Both operators are used for comparing two values for "equality," but the "loose" vs. "strict" indicates a **very important** difference in behavior between the two, specifically in how they decide "equality."

A very common misconception about these two operators is: "`==` checks values for equality and `===` checks both values and types for equality." While that sounds nice and reasonable, it's inaccurate. Countless well-respected JavaScript books and blogs have said exactly that, but unfortunately they're all *wrong*.

The correct description is: "`==` allows coercion in the equality comparison and `===` disallows coercion."

### Equality Performance

Stop and think about the difference between the first (inaccurate) explanation and this second (accurate) one.

In the first explanation, it seems obvious that `===` is *doing more work* than `==`, because it has to *also* check the type. In the second explanation, `==` is the one *doing more work* because it has to follow through the steps of coercion if the types are different.

Don't fall into the trap, as many have, of thinking this has anything to do with performance, though, as if `==` is going to be slower than `===` in any relevant way. While it's measurable that coercion does take *a little bit* of processing time, it's mere microseconds (yes, that's millionths of a second!).

If you're comparing two values of the same types, `==` and `===` use the identical algorithm, and so other than minor differences in engine implementation, they should do the same work.

If you're comparing two values of different types, the performance isn't the important factor. What you should be asking yourself is: when comparing these two values, do I want coercion or not?

If you want coercion, use `==` loose equality, but if you don't want coercion, use `===` strict equality.

**Note:** The implication here then is that both `==` and `===` check the types of their operands. The difference is in how they respond if the types don't match.

### Abstract Equality

The `==` operator's behavior is defined as "The Abstract Equality Comparison Algorithm" in section 11.9.3 of the ES5 spec. What's listed there is a comprehensive but simple algorithm that explicitly states every possible combination of types, and how the coercions (if necessary) should happen for each combination.

**Warning:** When (*implicit*) coercion is maligned as being too complicated and too flawed to be a *useful good part*, it is these rules of "abstract equality" that are being condemned. Generally, they are said to be too complex and too unintuitive for developers to practically learn and use, and that they are prone more to causing bugs in JS programs than to enabling greater code readability. I believe this is a flawed premise -- that you readers are competent developers who write (and read and understand!) algorithms (aka code) all day long. So, what follows is a plain exposition of the "abstract equality" in simple terms. But I implore you to also read the ES5 spec section 11.9.3. I think you'll be surprised at just how reasonable it is.

Basically, the first clause (11.9.3.1) says, if the two values being compared are of the same type, they are simply and naturally compared via Identity as you'd expect. For example, `42` is only equal to `42`, and `"abc"` is only equal to `"abc"`.

Some minor exceptions to normal expectation to be aware of:

* `NaN` is never equal to itself (see Chapter 2)
* `+0` and `-0` are equal to each other (see Chapter 2)

The final provision in clause 11.9.3.1 is for `==` loose equality comparison with `object`s (including `function`s and `array`s). Two such values are only *equal* if they are both references to *the exact same value*. No coercion occurs here.

**Note:** The `===` strict equality comparison is defined identically to 11.9.3.1, including the provision about two `object` values. It's a very little known fact that **`==` and `===` behave identically** in the case where two `object`s are being compared!

The rest of the algorithm in 11.9.3 specifies that if you use `==` loose equality to compare two values of different types, one or both of the values will need to be *implicitly* coerced. This coercion happens so that both values eventually end up as the same type, which can then directly be compared for equality using simple value Identity.

**Note:** The `!=` loose not-equality operation is defined exactly as you'd expect, in that it's literally the `==` operation comparison performed in its entirety, then the negation of the result. The same goes for the `!==` strict not-equality operation.

#### Comparing: `string`s to `number`s

To illustrate `==` coercion, let's first build off the `string` and `number` examples earlier in this chapter:

```js
var a = 42;
var b = "42";

a === b;	// false
a == b;		// true
```

As we'd expect, `a === b` fails, because no coercion is allowed, and indeed the `42` and `"42"` values are different.

However, the second comparison `a == b` uses loose equality, which means that if the types happen to be different, the comparison algorithm will perform *implicit* coercion on one or both values.

But exactly what kind of coercion happens here? Does the `a` value of `42` become a `string`, or does the `b` value of `"42"` become a `number`?

In the ES5 spec, clauses 11.9.3.4-5 say:

> 4. If Type(x) is Number and Type(y) is String,
>    return the result of the comparison x == ToNumber(y).
> 5. If Type(x) is String and Type(y) is Number,
>    return the result of the comparison ToNumber(x) == y.

**Warning:** The spec uses `Number` and `String` as the formal names for the types, while this book prefers `number` and `string` for the primitive types. Do not let the capitalization of `Number` in the spec confuse you for the `Number()` native function. For our purposes, the capitalization of the type name is irrelevant -- they have basically the same meaning.

Clearly, the spec says the `"42"` value is coerced to a `number` for the comparison. The *how* of that coercion has already been covered earlier, specifically with the `ToNumber` abstract operation. In this case, it's quite obvious then that the resulting two `42` values are equal.

#### Comparing: anything to `boolean`

One of the biggest gotchas with the *implicit* coercion of `==` loose equality pops up when you try to compare a value directly to `true` or `false`.

Consider:

```js
var a = "42";
var b = true;

a == b;	// false
```

Wait, what happened here!? We know that `"42"` is a truthy value (see earlier in this chapter). So, how come it's not `==` loose equal to `true`?

The reason is both simple and deceptively tricky. It's so easy to misunderstand, many JS developers never pay close enough attention to fully grasp it.

Let's again quote the spec, clauses 11.9.3.6-7:

> 6. If Type(x) is Boolean,
>    return the result of the comparison ToNumber(x) == y.
> 7. If Type(y) is Boolean,
>    return the result of the comparison x == ToNumber(y).

Let's break that down. First:

```js
var x = true;
var y = "42";

x == y; // false
```

The `Type(x)` is indeed `Boolean`, so it performs `ToNumber(x)`, which coerces `true` to `1`. Now, `1 == "42"` is evaluated. The types are still different, so (essentially recursively) we reconsult the algorithm, which just as above will coerce `"42"` to `42`, and `1 == 42` is clearly `false`.

Reverse it, and we still get the same outcome:

```js
var x = "42";
var y = false;

x == y; // false
```

The `Type(y)` is `Boolean` this time, so `ToNumber(y)` yields `0`. `"42" == 0` recursively becomes `42 == 0`, which is of course `false`.

In other words, **the value `"42"` is neither `== true` nor `== false`.** At first, that statement might seem crazy. How can a value be neither truthy nor falsy?

But that's the problem! You're asking the wrong question, entirely. It's not your fault, really. Your brain is tricking you.

`"42"` is indeed truthy, but `"42" == true` **is not performing a boolean test/coercion** at all, no matter what your brain says. `"42"` *is not* being coerced to a `boolean` (`true`), but instead `true` is being coerced to a `1`, and then `"42"` is being coerced to `42`.

Whether we like it or not, `ToBoolean` is not even involved here, so the truthiness or falsiness of `"42"` is irrelevant to the `==` operation!

What *is* relevant is to understand how the `==` comparison algorithm behaves with all the different type combinations. As it regards a `boolean` value on either side of the `==`, a `boolean` always coerces to a `number` *first*.

If that seems strange to you, you're not alone. I personally would recommend to never, ever, under any circumstances, use `== true` or `== false`. Ever.

But remember, I'm only talking about `==` here. `=== true` and `=== false` wouldn't allow the coercion, so they're safe from this hidden `ToNumber` coercion.

Consider:

```js
var a = "42";

// bad (will fail!):
if (a == true) {
	// ..
}

// also bad (will fail!):
if (a === true) {
	// ..
}

// good enough (works implicitly):
if (a) {
	// ..
}

// better (works explicitly):
if (!!a) {
	// ..
}

// also great (works explicitly):
if (Boolean( a )) {
	// ..
}
```

If you avoid ever using `== true` or `== false` (aka loose equality with `boolean`s) in your code, you'll never have to worry about this truthiness/falsiness mental gotcha.

#### Comparing: `null`s to `undefined`s

Another example of *implicit* coercion can be seen with `==` loose equality between `null` and `undefined` values. Yet again quoting the ES5 spec, clauses 11.9.3.2-3:

> 2. If x is null and y is undefined, return true.
> 3. If x is undefined and y is null, return true.

`null` and `undefined`, when compared with `==` loose equality, equate to (aka coerce to) each other (as well as themselves, obviously), and no other values in the entire language.

What this means is that `null` and `undefined` can be treated as indistinguishable for comparison purposes, if you use the `==` loose equality operator to allow their mutual *implicit* coercion.

```js
var a = null;
var b;

a == b;		// true
a == null;	// true
b == null;	// true

a == false;	// false
b == false;	// false
a == "";	// false
b == "";	// false
a == 0;		// false
b == 0;		// false
```

The coercion between `null` and `undefined` is safe and predictable, and no other values can give false positives in such a check. I recommend using this coercion to allow `null` and `undefined` to be indistinguishable and thus treated as the same value.

For example:

```js
var a = doSomething();

if (a == null) {
	// ..
}
```

The `a == null` check will pass only if `doSomething()` returns either `null` or `undefined`, and will fail with any other value, even other falsy values like `0`, `false`, and `""`.

The *explicit* form of the check, which disallows any such coercion, is (I think) unnecessarily much uglier (and perhaps a tiny bit less performant!):

```js
var a = doSomething();

if (a === undefined || a === null) {
	// ..
}
```

In my opinion, the form `a == null` is yet another example where *implicit* coercion improves code readability, but does so in a reliably safe way.

#### Comparing: `object`s to non-`object`s

If an `object`/`function`/`array` is compared to a simple scalar primitive (`string`, `number`, or `boolean`), the ES5 spec says in clauses 11.9.3.8-9:

> 8. If Type(x) is either String or Number and Type(y) is Object,
>    return the result of the comparison x == ToPrimitive(y).
> 9. If Type(x) is Object and Type(y) is either String or Number,
>    return the result of the comparison ToPrimitive(x) == y.

**Note:** You may notice that these clauses only mention `String` and `Number`, but not `Boolean`. That's because, as quoted earlier, clauses 11.9.3.6-7 take care of coercing any `Boolean` operand presented to a `Number` first.

Consider:

```js
var a = 42;
var b = [ 42 ];

a == b;	// true
```

The `[ 42 ]` value has its `ToPrimitive` abstract operation called (see the "Abstract Value Operations" section earlier), which results in the `"42"` value. From there, it's just `42 == "42"`, which as we've already covered becomes `42 == 42`, so `a` and `b` are found to be coercively equal.

**Tip:** All the quirks of the `ToPrimitive` abstract operation that we discussed earlier in this chapter (`toString()`, `valueOf()`) apply here as you'd expect. This can be quite useful if you have a complex data structure that you want to define a custom `valueOf()` method on, to provide a simple value for equality comparison purposes.

In Chapter 3, we covered "unboxing," where an `object` wrapper around a primitive value (like from `new String("abc")`, for instance) is unwrapped, and the underlying primitive value (`"abc"`) is returned. This behavior is related to the `ToPrimitive` coercion in the `==` algorithm:

```js
var a = "abc";
var b = Object( a );	// same as `new String( a )`

a === b;				// false
a == b;					// true
```

`a == b` is `true` because `b` is coerced (aka "unboxed," unwrapped) via `ToPrimitive` to its underlying `"abc"` simple scalar primitive value, which is the same as the value in `a`.

There are some values where this is not the case, though, because of other overriding rules in the `==` algorithm. Consider:

```js
var a = null;
var b = Object( a );	// same as `Object()`
a == b;					// false

var c = undefined;
var d = Object( c );	// same as `Object()`
c == d;					// false

var e = NaN;
var f = Object( e );	// same as `new Number( e )`
e == f;					// false
```

The `null` and `undefined` values cannot be boxed -- they have no object wrapper equivalent -- so `Object(null)` is just like `Object()` in that both just produce a normal object.

`NaN` can be boxed to its `Number` object wrapper equivalent, but when `==` causes an unboxing, the `NaN == NaN` comparison fails because `NaN` is never equal to itself (see Chapter 2).

### Edge Cases

Now that we've thoroughly examined how the *implicit* coercion of `==` loose equality works (in both sensible and surprising ways), let's try to call out the worst, craziest corner cases so we can see what we need to avoid to not get bitten with coercion bugs.

First, let's examine how modifying the built-in native prototypes can produce crazy results:

#### A Number By Any Other Value Would...

```js
Number.prototype.valueOf = function() {
	return 3;
};

new Number( 2 ) == 3;	// true
```

**Warning:** `2 == 3` would not have fallen into this trap, because neither `2` nor `3` would have invoked the built-in `Number.prototype.valueOf()` method because both are already primitive `number` values and can be compared directly. However, `new Number(2)` must go through the `ToPrimitive` coercion, and thus invoke `valueOf()`.

Evil, huh? Of course it is. No one should ever do such a thing. The fact that you *can* do this is sometimes used as a criticism of coercion and `==`. But that's misdirected frustration. JavaScript is not *bad* because you can do such things, a developer is *bad* **if they do such things**. Don't fall into the "my programming language should protect me from myself" fallacy.

Next, let's consider another tricky example, which takes the evil from the previous example to another level:

```js
if (a == 2 && a == 3) {
	// ..
}
```

You might think this would be impossible, because `a` could never be equal to both `2` and `3` *at the same time*. But "at the same time" is inaccurate, since the first expression `a == 2` happens strictly *before* `a == 3`.

So, what if we make `a.valueOf()` have side effects each time it's called, such that the first time it returns `2` and the second time it's called it returns `3`? Pretty easy:

```js
var i = 2;

Number.prototype.valueOf = function() {
	return i++;
};

var a = new Number( 42 );

if (a == 2 && a == 3) {
	console.log( "Yep, this happened." );
}
```

Again, these are evil tricks. Don't do them. But also don't use them as complaints against coercion. Potential abuses of a mechanism are not sufficient evidence to condemn the mechanism. Just avoid these crazy tricks, and stick only with valid and proper usage of coercion.

#### False-y Comparisons

The most common complaint against *implicit* coercion in `==` comparisons comes from how falsy values behave surprisingly when compared to each other.

To illustrate, let's look at a list of the corner-cases around falsy value comparisons, to see which ones are reasonable and which are troublesome:

```js
"0" == null;			// false
"0" == undefined;		// false
"0" == false;			// true -- UH OH!
"0" == NaN;				// false
"0" == 0;				// true
"0" == "";				// false

false == null;			// false
false == undefined;		// false
false == NaN;			// false
false == 0;				// true -- UH OH!
false == "";			// true -- UH OH!
false == [];			// true -- UH OH!
false == {};			// false

"" == null;				// false
"" == undefined;		// false
"" == NaN;				// false
"" == 0;				// true -- UH OH!
"" == [];				// true -- UH OH!
"" == {};				// false

0 == null;				// false
0 == undefined;			// false
0 == NaN;				// false
0 == [];				// true -- UH OH!
0 == {};				// false
```

In this list of 24 comparisons, 17 of them are quite reasonable and predictable. For example, we know that `""` and `NaN` are not at all equatable values, and indeed they don't coerce to be loose equals, whereas `"0"` and `0` are reasonably equatable and *do* coerce as loose equals.

However, seven of the comparisons are marked with "UH OH!" because as false positives, they are much more likely gotchas that could trip you up. `""` and `0` are definitely distinctly different values, and it's rare you'd want to treat them as equatable, so their mutual coercion is troublesome. Note that there aren't any false negatives here.

#### The Crazy Ones

We don't have to stop there, though. We can keep looking for even more troublesome coercions:

```js
[] == ![];		// true
```

Oooo, that seems at a higher level of crazy, right!? Your brain may likely trick you that you're comparing a truthy to a falsy value, so the `true` result is surprising, as we *know* a value can never be truthy and falsy at the same time!

But that's not what's actually happening. Let's break it down. What do we know about the `!` unary operator? It explicitly coerces to a `boolean` using the `ToBoolean` rules (and it also flips the parity). So before `[] == ![]` is even processed, it's actually already translated to `[] == false`. We already saw that form in our above list (`false == []`), so its surprise result is *not new* to us.

How about other corner cases?

```js
2 == [2];		// true
"" == [null];	// true
```

As we said earlier in our `ToNumber` discussion, the right-hand side `[2]` and `[null]` values will go through a `ToPrimitive` coercion so they can be more readily compared to the simple primitives (`2` and `""`, respectively) on the left-hand side. Since the `valueOf()` for `array` values just returns the `array` itself, coercion falls to stringifying the `array`.

`[2]` will become `"2"`, which then is `ToNumber` coerced to `2` for the right-hand side value in the first comparison. `[null]` just straight becomes `""`.

So, `2 == 2` and `"" == ""` are completely understandable.

If your instinct is to still dislike these results, your frustration is not actually with coercion like you probably think it is. It's actually a complaint against the default `array` values' `ToPrimitive` behavior of coercing to a `string` value. More likely, you'd just wish that `[2].toString()` didn't return `"2"`, or that `[null].toString()` didn't return `""`.

But what exactly *should* these `string` coercions result in? I can't really think of any other appropriate `string` coercion of `[2]` than `"2"`, except perhaps `"[2]"` -- but that could be very strange in other contexts!

You could rightly make the case that since `String(null)` becomes `"null"`, then `String([null])` should also become `"null"`. That's a reasonable assertion. So, that's the real culprit.

*Implicit* coercion itself isn't the evil here. Even an *explicit* coercion of `[null]` to a `string` results in `""`. What's at odds is whether it's sensible at all for `array` values to stringify to the equivalent of their contents, and exactly how that happens. So, direct your frustration at the rules for `String( [..] )`, because that's where the craziness stems from. Perhaps there should be no stringification coercion of `array`s at all? But that would have lots of other downsides in other parts of the language.

Another famously cited gotcha:

```js
0 == "\n";		// true
```

As we discussed earlier with empty `""`, `"\n"` (or `" "` or any other whitespace combination) is coerced via `ToNumber`, and the result is `0`. What other `number` value would you expect whitespace to coerce to? Does it bother you that *explicit* `Number(" ")` yields `0`?

Really the only other reasonable `number` value that empty strings or whitespace strings could coerce to is the `NaN`. But would that *really* be better? The comparison `" " == NaN` would of course fail, but it's unclear that we'd have really *fixed* any of the underlying concerns.

The chances that a real-world JS program fails because `0 == "\n"` are awfully rare, and such corner cases are easy to avoid.

Type conversions **always** have corner cases, in any language -- nothing specific to coercion. The issues here are about second-guessing a certain set of corner cases (and perhaps rightly so!?), but that's not a salient argument against the overall coercion mechanism.

Bottom line: almost any crazy coercion between *normal values* that you're likely to run into (aside from intentionally tricky `valueOf()` or `toString()` hacks as earlier) will boil down to the short seven-item list of gotcha coercions we've identified above.

To contrast against these 24 likely suspects for coercion gotchas, consider another list like this:

```js
42 == "43";							// false
"foo" == 42;						// false
"true" == true;						// false

42 == "42";							// true
"foo" == [ "foo" ];					// true
```

In these nonfalsy, noncorner cases (and there are literally an infinite number of comparisons we could put on this list), the coercion results are totally safe, reasonable, and explainable.

#### Sanity Check

OK, we've definitely found some crazy stuff when we've looked deeply into *implicit* coercion. No wonder that most developers claim coercion is evil and should be avoided, right!?

But let's take a step back and do a sanity check.

By way of magnitude comparison, we have *a list* of seven troublesome gotcha coercions, but we have *another list* of (at least 17, but actually infinite) coercions that are totally sane and explainable.

If you're looking for a textbook example of "throwing the baby out with the bathwater," this is it: discarding the entirety of coercion (the infinitely large list of safe and useful behaviors) because of a list of literally just seven gotchas.

The more prudent reaction would be to ask, "how can I use the countless *good parts* of coercion, but avoid the few *bad parts*?"

Let's look again at the *bad* list:

```js
"0" == false;			// true -- UH OH!
false == 0;				// true -- UH OH!
false == "";			// true -- UH OH!
false == [];			// true -- UH OH!
"" == 0;				// true -- UH OH!
"" == [];				// true -- UH OH!
0 == [];				// true -- UH OH!
```

Four of the seven items on this list involve `== false` comparison, which we said earlier you should **always, always** avoid. That's a pretty easy rule to remember.

Now the list is down to three.

```js
"" == 0;				// true -- UH OH!
"" == [];				// true -- UH OH!
0 == [];				// true -- UH OH!
```

Are these reasonable coercions you'd do in a normal JavaScript program? Under what conditions would they really happen?

I don't think it's terribly likely that you'd literally use `== []` in a `boolean` test in your program, at least not if you know what you're doing. You'd probably instead be doing `== ""` or `== 0`, like:

```js
function doSomething(a) {
	if (a == "") {
		// ..
	}
}
```

You'd have an oops if you accidentally called `doSomething(0)` or `doSomething([])`. Another scenario:

```js
function doSomething(a,b) {
	if (a == b) {
		// ..
	}
}
```

Again, this could break if you did something like `doSomething("",0)` or `doSomething([],"")`.

So, while the situations *can* exist where these coercions will bite you, and you'll want to be careful around them, they're probably not super common on the whole of your code base.

#### Safely Using Implicit Coercion

The most important advice I can give you: examine your program and reason about what values can show up on either side of an `==` comparison. To effectively avoid issues with such comparisons, here's some heuristic rules to follow:

1. If either side of the comparison can have `true` or `false` values, don't ever, EVER use `==`.
2. If either side of the comparison can have `[]`, `""`, or `0` values, seriously consider not using `==`.

In these scenarios, it's almost certainly better to use `===` instead of `==`, to avoid unwanted coercion. Follow those two simple rules and pretty much all the coercion gotchas that could reasonably hurt you will effectively be avoided.

**Being more explicit/verbose in these cases will save you from a lot of headaches.**

The question of `==` vs. `===` is really appropriately framed as: should you allow coercion for a comparison or not?

There's lots of cases where such coercion can be helpful, allowing you to more tersely express some comparison logic (like with `null` and `undefined`, for example).

In the overall scheme of things, there's relatively few cases where *implicit* coercion is truly dangerous. But in those places, for safety sake, definitely use `===`.

**Tip:** Another place where coercion is guaranteed *not* to bite you is with the `typeof` operator. `typeof` is always going to return you one of seven strings (see Chapter 1), and none of them are the empty `""` string. As such, there's no case where checking the type of some value is going to run afoul of *implicit* coercion. `typeof x == "function"` is 100% as safe and reliable as `typeof x === "function"`. Literally, the spec says the algorithm will be identical in this situation. So, don't just blindly use `===` everywhere simply because that's what your code tools tell you to do, or (worst of all) because you've been told in some book to **not think about it**. You own the quality of your code.

Is *implicit* coercion evil and dangerous? In a few cases, yes, but overwhelmingly, no.

Be a responsible and mature developer. Learn how to use the power of coercion (both *explicit* and *implicit*) effectively and safely. And teach those around you to do the same.

Here's a handy table made by Alex Dorey (@dorey on GitHub) to visualize a variety of comparisons:

<img src="fig1.png" width="600">

Source: https://github.com/dorey/JavaScript-Equality-Table

## Abstract Relational Comparison

While this part of *implicit* coercion often gets a lot less attention, it's important nonetheless to think about what happens with `a < b` comparisons (similar to how we just examined `a == b` in depth).

The "Abstract Relational Comparison" algorithm in ES5 section 11.8.5 essentially divides itself into two parts: what to do if the comparison involves both `string` values (second half), or anything else (first half).

**Note:** The algorithm is only defined for `a < b`. So, `a > b` is handled as `b < a`.

The algorithm first calls `ToPrimitive` coercion on both values, and if the return result of either call is not a `string`, then both values are coerced to `number` values using the `ToNumber` operation rules, and compared numerically.

For example:

```js
var a = [ 42 ];
var b = [ "43" ];

a < b;	// true
b < a;	// false
```

**Note:** Similar caveats for `-0` and `NaN` apply here as they did in the `==` algorithm discussed earlier.

However, if both values are `string`s for the `<` comparison, simple lexicographic (natural alphabetic) comparison on the characters is performed:

```js
var a = [ "42" ];
var b = [ "043" ];

a < b;	// false
```

`a` and `b` are *not* coerced to `number`s, because both of them end up as `string`s after the `ToPrimitive` coercion on the two `array`s. So, `"42"` is compared character by character to `"043"`, starting with the first characters `"4"` and `"0"`, respectively. Since `"0"` is lexicographically *less than* than `"4"`, the comparison returns `false`.

The exact same behavior and reasoning goes for:

```js
var a = [ 4, 2 ];
var b = [ 0, 4, 3 ];

a < b;	// false
```

Here, `a` becomes `"4,2"` and `b` becomes `"0,4,3"`, and those lexicographically compare identically to the previous snippet.

What about:

```js
var a = { b: 42 };
var b = { b: 43 };

a < b;	// ??
```

`a < b` is also `false`, because `a` becomes `[object Object]` and `b` becomes `[object Object]`, and so clearly `a` is not lexicographically less than `b`.

But strangely:

```js
var a = { b: 42 };
var b = { b: 43 };

a < b;	// false
a == b;	// false
a > b;	// false

a <= b;	// true
a >= b;	// true
```

Why is `a == b` not `true`? They're the same `string` value (`"[object Object]"`), so it seems they should be equal, right? Nope. Recall the previous discussion about how `==` works with `object` references.

But then how are `a <= b` and `a >= b` resulting in `true`, if `a < b` **and** `a == b` **and** `a > b` are all `false`?

Because the spec says for `a <= b`, it will actually evaluate `b < a` first, and then negate that result. Since `b < a` is *also* `false`, the result of `a <= b` is `true`.

That's probably awfully contrary to how you might have explained what `<=` does up to now, which would likely have been the literal: "less than *or* equal to." JS more accurately considers `<=` as "not greater than" (`!(a > b)`, which JS treats as `!(b < a)`). Moreover, `a >= b` is explained by first considering it as `b <= a`, and then applying the same reasoning.

Unfortunately, there is no "strict relational comparison" as there is for equality. In other words, there's no way to prevent *implicit* coercion from occurring with relational comparisons like `a < b`, other than to ensure that `a` and `b` are of the same type explicitly before making the comparison.

Use the same reasoning from our earlier `==` vs. `===` sanity check discussion. If coercion is helpful and reasonably safe, like in a `42 < "43"` comparison, **use it**. On the other hand, if you need to be safe about a relational comparison, *explicitly coerce* the values first, before using `<` (or its counterparts).

```js
var a = [ 42 ];
var b = "043";

a < b;						// false -- string comparison!
Number( a ) < Number( b );	// true -- number comparison!
```

## Review

In this chapter, we turned our attention to how JavaScript type conversions happen, called **coercion**, which can be characterized as either *explicit* or *implicit*.

Coercion gets a bad rap, but it's actually quite useful in many cases. An important task for the responsible JS developer is to take the time to learn all the ins and outs of coercion to decide which parts will help improve their code, and which parts they really should avoid.

*Explicit* coercion is code which is obvious that the intent is to convert a value from one type to another. The benefit is improvement in readability and maintainability of code by reducing confusion.

*Implicit* coercion is coercion that is "hidden" as a side-effect of some other operation, where it's not as obvious that the type conversion will occur. While it may seem that *implicit* coercion is the opposite of *explicit* and is thus bad (and indeed, many think so!), actually *implicit* coercion is also about improving the readability of code.

Especially for *implicit*, coercion must be used responsibly and consciously. Know why you're writing the code you're writing, and how it works. Strive to write code that others will easily be able to learn from and understand as well.
